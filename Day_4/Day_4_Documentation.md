# 🚀 Day 4: GLS, Blocking vs Non-Blocking, and Synthesis-Simulation Mismatch

**💡 Why Today is Important:**  
In digital design, writing correct RTL is only half the story. After synthesis, your design is mapped to **actual gates and flip-flops** in a technology library. Even if your RTL simulation passes, the **synthesized netlist may behave differently**!  

Today, we focus on:  

1. **Gate Level Simulation (GLS)** – Validate your design **after synthesis**.  
2. **Blocking vs Non-Blocking Assignments** – Avoid subtle bugs in sequential logic.  
3. **Synthesis-Simulation Mismatches** – Learn why RTL and netlist outputs may differ and how to fix them.  

By mastering these topics, you will **ensure your design is functionally correct and timing-accurate**, avoiding costly errors before tapeout.

---

## 🔹 What is GLS?

**GLS** stands for **Gate Level Simulation**.  

- In **RTL simulation**, the **testbench runs with the RTL code** as the Design Under Test (DUT).  
- In **GLS**, the **testbench runs with the synthesized netlist** as the DUT.  
- The **netlist** is logically the same as the RTL but expressed using **standard cell gates and flip-flops** from the target technology library.  

**Example Workflow:**

- RTL simulation: Testbench + RTL code  
- GLS simulation: Testbench + Synthesized netlist

---

## ❓ Why GLS is Needed?

1. **Verify logical correctness after synthesis** – Ensures the functional behavior of the netlist matches the RTL.  
2. **Timing-aware verification** – RTL simulation ignores gate delays. Netlist simulation includes timing information if delay annotations are present.  
3. **Delay-annotated GLS** – Helps catch setup/hold violations and timing issues before tapeout.  
4. **Detect synthesis-related mismatches** – Improper coding styles, incomplete sensitivity lists, or incorrect blocking/non-blocking usage may cause netlist behavior to differ from RTL.  
5. **Final verification confidence** – Acts as the last step of functional and timing validation before fabrication.

---

# 📌 GLS Using Icarus Verilog (iverilog)

In previous days, simulations were run with **RTL as the DUT**. In GLS, the **DUT is the synthesized netlist**.  

**Files Needed:**  

- **Design** → Netlist (gate-level Verilog generated by synthesis)  
- **Testbench** → Stimulus file  
- **Gate-Level Models** → Standard cells or library models  

GLS helps verify that the **netlist produces the same output as RTL** and validates timing if delays are annotated.

---

## 🔹 Types of Gate-Level Models

1. **Functional Models** – Only describe logical function, no timing information.  
2. **Timing-Aware Models** – Include gate delays along with logic. Timing-aware GLS ensures correct setup and hold timings.  

---

## 🔹 Why GLS is Needed

- Netlist represents the same logic as RTL but is mapped to actual gates.  
- Timing-aware netlists include propagation delays from the library.  
- GLS helps in:
  - Timing validation – Ensure setup/hold times are met  
  - Functional verification – Check logical correctness after synthesis

---

## 🔹 Example

Netlist logic: `y = (a AND b) OR c`  

- GLS verifies that this gate-level implementation produces the same output for all input combinations as RTL.  
- If timing-annotated, GLS also shows propagation delay effects.

---

# 📌 Synthesis and Simulation Mismatch

Sometimes, **RTL simulation output** does not match **synthesized netlist output**.  

### 🔹 Common Causes

1. Missing sensitivity list  
2. Blocking vs Non-Blocking assignments  
3. Non-standard Verilog coding  

---

## 🔹 Missing Sensitivity List

- Simulator updates output only when a signal in the sensitivity list changes.  
- If the sensitivity list is incomplete, some input changes **do not trigger the always block**, leading to mismatch.

**Example:**  

- An always block triggered only by `sel`:

  - Output changes correctly when `sel` changes.  
  - But if `i0` or `i1` change while `sel` remains the same, output retains old value → mismatch with synthesized hardware.

**Solution:** Use `always @(*)` so that the block is evaluated whenever **any input changes**, ensuring correct combinational behavior in both RTL and synthesized netlist.

---

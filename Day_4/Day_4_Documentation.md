# ğŸš€ Day 4: GLS, Blocking vs Non-Blocking, and Synthesis-Simulation Mismatch

**ğŸ’¡ Why Today is Important:**  
In digital design, writing correct RTL is only half the story. After synthesis, your design is mapped to **actual gates and flip-flops** in a technology library. Even if your RTL simulation passes, the **synthesized netlist may behave differently**!  

Today, we focus on:  

1. **Gate Level Simulation (GLS)** â€“ Validate your design **after synthesis**.  
2. **Blocking vs Non-Blocking Assignments** â€“ Avoid subtle bugs in sequential logic.  
3. **Synthesis-Simulation Mismatches** â€“ Learn why RTL and netlist outputs may differ and how to fix them.  

By mastering these topics, you will **ensure your design is functionally correct and timing-accurate**, avoiding costly errors before tapeout.

---

## ğŸ”¹ What is GLS?

**GLS** stands for **Gate Level Simulation**.  

- In **RTL simulation**, the **testbench runs with the RTL code** as the Design Under Test (DUT).  
- In **GLS**, the **testbench runs with the synthesized netlist** as the DUT.  
- The **netlist** is logically the same as the RTL but expressed using **standard cell gates and flip-flops** from the target technology library.  

**Example Workflow:**

- RTL simulation: Testbench + RTL code  
- GLS simulation: Testbench + Synthesized netlist

---

## â“ Why GLS is Needed?

1. **Verify logical correctness after synthesis** â€“ Ensures the functional behavior of the netlist matches the RTL.  
2. **Timing-aware verification** â€“ RTL simulation ignores gate delays. Netlist simulation includes timing information if delay annotations are present.  
3. **Delay-annotated GLS** â€“ Helps catch setup/hold violations and timing issues before tapeout.  
4. **Detect synthesis-related mismatches** â€“ Improper coding styles, incomplete sensitivity lists, or incorrect blocking/non-blocking usage may cause netlist behavior to differ from RTL.  
5. **Final verification confidence** â€“ Acts as the last step of functional and timing validation before fabrication.

---

# ğŸ“Œ GLS Using Icarus Verilog (iverilog)

In previous days, simulations were run with **RTL as the DUT**. In GLS, the **DUT is the synthesized netlist**.  

**Files Needed:**  

- **Design** â†’ Netlist (gate-level Verilog generated by synthesis)  
- **Testbench** â†’ Stimulus file  
- **Gate-Level Models** â†’ Standard cells or library models  

GLS helps verify that the **netlist produces the same output as RTL** and validates timing if delays are annotated.

---

## ğŸ”¹ Types of Gate-Level Models

1. **Functional Models** â€“ Only describe logical function, no timing information.  
2. **Timing-Aware Models** â€“ Include gate delays along with logic. Timing-aware GLS ensures correct setup and hold timings.  

---

## ğŸ”¹ Why GLS is Needed

- Netlist represents the same logic as RTL but is mapped to actual gates.  
- Timing-aware netlists include propagation delays from the library.  
- GLS helps in:
  - Timing validation â€“ Ensure setup/hold times are met  
  - Functional verification â€“ Check logical correctness after synthesis

---

## ğŸ”¹ Example

Netlist logic: `y = (a AND b) OR c`  

- GLS verifies that this gate-level implementation produces the same output for all input combinations as RTL.  
- If timing-annotated, GLS also shows propagation delay effects.

---

# ğŸ“Œ Synthesis and Simulation Mismatch

Sometimes, **RTL simulation output** does not match **synthesized netlist output**.  

### ğŸ”¹ Common Causes

1. Missing sensitivity list  
2. Blocking vs Non-Blocking assignments  
3. Non-standard Verilog coding  

---

## ğŸ”¹ Missing Sensitivity List

- Simulator updates output only when a signal in the sensitivity list changes.  
- If the sensitivity list is incomplete, some input changes **do not trigger the always block**, leading to mismatch.

**Example:**  

- An always block triggered only by `sel`:

  - Output changes correctly when `sel` changes.  
  - But if `i0` or `i1` change while `sel` remains the same, output retains old value â†’ mismatch with synthesized hardware.

**Solution:** Use `always @(*)` so that the block is evaluated whenever **any input changes**, ensuring correct combinational behavior in both RTL and synthesized netlist.

---

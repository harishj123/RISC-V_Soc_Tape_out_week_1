# 🚀 Day 4: GLS, Blocking vs Non-Blocking, and Synthesis-Simulation Mismatch

**💡 Why Today is Important:**  
In digital design, writing correct RTL is only half the story. After synthesis, your design is mapped to **actual gates and flip-flops** in a technology library. Even if your RTL simulation passes, the **synthesized netlist may behave differently**!  

Today, we focus on:  

1. **Gate Level Simulation (GLS)** – Validate your design **after synthesis**.  
2. **Blocking vs Non-Blocking Assignments** – Avoid subtle bugs in sequential logic.  
3. **Synthesis-Simulation Mismatches** – Learn why RTL and netlist outputs may differ and how to fix them.  

By mastering these topics, you will **ensure your design is functionally correct and timing-accurate**, avoiding costly errors before tapeout.

---

## 🔹 What is GLS?

**GLS** stands for **Gate Level Simulation**.  

- In **RTL simulation**, the **testbench runs with the RTL code** as the Design Under Test (DUT).  
- In **GLS**, the **testbench runs with the synthesized netlist** as the DUT.  
- The **netlist** is logically the same as the RTL but expressed using **standard cell gates and flip-flops** from the target technology library.  

**Example Workflow:**

- RTL simulation: Testbench + RTL code  
- GLS simulation: Testbench + Synthesized netlist

---

## ❓ Why GLS is Needed?

1. **Verify logical correctness after synthesis** – Ensures the functional behavior of the netlist matches the RTL.  
2. **Timing-aware verification** – RTL simulation ignores gate delays. Netlist simulation includes timing information if delay annotations are present.  
3. **Delay-annotated GLS** – Helps catch setup/hold violations and timing issues before tapeout.  
4. **Detect synthesis-related mismatches** – Improper coding styles, incomplete sensitivity lists, or incorrect blocking/non-blocking usage may cause netlist behavior to differ from RTL.  
5. **Final verification confidence** – Acts as the last step of functional and timing validation before fabrication.

---

# 📌 GLS Using Icarus Verilog (iverilog)

In previous days, simulations were run with **RTL as the DUT**. In GLS, the **DUT is the synthesized netlist**.  

**Files Needed:**  

- **Design** → Netlist (gate-level Verilog generated by synthesis)  
- **Testbench** → Stimulus file  
- **Gate-Level Models** → Standard cells or library models  

GLS helps verify that the **netlist produces the same output as RTL** and validates timing if delays are annotated.

---

## 🔹 Types of Gate-Level Models

1. **Functional Models** – Only describe logical function, no timing information.  
2. **Timing-Aware Models** – Include gate delays along with logic. Timing-aware GLS ensures correct setup and hold timings.  

---

## 🔹 Why GLS is Needed

- Netlist represents the same logic as RTL but is mapped to actual gates.  
- Timing-aware netlists include propagation delays from the library.  
- GLS helps in:
  - Timing validation – Ensure setup/hold times are met  
  - Functional verification – Check logical correctness after synthesis

---

## 🔹 Example

Netlist logic: `y = (a AND b) OR c`  

- GLS verifies that this gate-level implementation produces the same output for all input combinations as RTL.  
- If timing-annotated, GLS also shows propagation delay effects.

---

# 📌 Synthesis and Simulation Mismatch

Sometimes, **RTL simulation output** does not match **synthesized netlist output**.  

### 🔹 Common Causes

1. Missing sensitivity list  
2. Blocking vs Non-Blocking assignments  
3. Non-standard Verilog coding  

---

## 🔹 Missing Sensitivity List

- Simulator updates output only when a signal in the sensitivity list changes.  
- If the sensitivity list is incomplete, some input changes **do not trigger the always block**, leading to mismatch.

**Example:**  

- An always block triggered only by `sel`:

  - Output changes correctly when `sel` changes.  
  - But if `i0` or `i1` change while `sel` remains the same, output retains old value → mismatch with synthesized hardware.

**Solution:** Use `always @(*)` so that the block is evaluated whenever **any input changes**, ensuring correct combinational behavior in both RTL and synthesized netlist.

---

# 🚀 Blocking vs Non-Blocking Statements in Verilog

In Verilog, **blocking (`=`)** and **non-blocking (`<=`)** statements are used **only inside `always` blocks**. Understanding their differences is critical for writing **correct sequential and combinational logic**.

---

## 🔹 Blocking Statements (`=`)

- Executes statements **in the order they are written**.  
- Each statement **must complete** before the next one starts.  
- Typically used in **combinational logic**.

**Example:**

```verilog
always @(*) begin
    a = b & c;
    e = a & f;
end
```

**Explanation:**

1. `a = b & c` is evaluated first.  
2. Then `e = a & f` is evaluated using the updated value of `a`.  
3. **Order matters** with blocking statements.

---

## 🔹 Non-Blocking Statements (`<=`)

- Executes **all RHS expressions in parallel** when the `always` block is entered.  
- Assigns values to LHS **after all RHS expressions are evaluated**.  
- Typically used in **sequential logic** (flip-flops, registers).  
- Execution **order does not matter**.

**Example:**

```verilog
always @(posedge clk) begin
    a <= b & c;
    e <= a & f;
end
```

**Explanation:**

1. `b`, `c`, `a`, and `f` are **evaluated first**.  
2. Then `a <= b & c` and `e <= a & f` are **assigned in parallel**.  
3. Ensures **correct sequential behavior** in registers.

---

## 🔹 Caveats with Blocking Statements in Sequential Logic

Consider this example:

```verilog
module example();
    reg q, q0, d;
    reg rst;
    always @(posedge clk) begin
        if (rst) begin
            q0 = 1'b0;
            q  = 1'b0;
        end
        else begin
            q  = q0;
            q0 = d;
        end
    end
endmodule
```

**Problem:**

- In the `else` block:
  - `q = q0;` uses **old value** of `q0`.  
  - `q0 = d;` updates `q0` **after** `q` is assigned.  
- This produces **incorrect sequential behavior**.

---

### ✅ Solution: Use Non-Blocking Statements

```verilog
always @(posedge clk) begin
    if (rst) begin
        q0 <= 1'b0;
        q  <= 1'b0;
    end
    else begin
        q0 <= d;
        q  <= q0;
    end
end
```

- Ensures that all RHS values are **evaluated first**, then assigned to LHS in **parallel**.  
- Correct behavior for sequential logic like flip-flops.

---

### 🔹 Another Caveat with Blocking Statements

Consider the following Verilog code:

```verilog
module code();
    reg q0;
    reg y, a, b, c, qo;
    always @(*) begin
        y  = qo & c;
        q0 = a | b;
    end
endmodule
```

**Explanation:**

- The `always @(*)` block is **evaluated whenever any input changes** (`a`, `b`, `c`, `qo`).  
- **Blocking assignment (`=`)** executes **sequentially**:  
  1. `y = qo & c;` is evaluated first.  
  2. `q0 = a | b;` is evaluated after.  

- **Problem:**  
  - `y` uses the **old value of `qo`** (from before `q0` is updated).  
  - This may produce **unintended temporary values** or glitches in simulation.  
  - After synthesis, **no delay is inserted**, so the hardware might **appear to work correctly**, but simulation shows the sequential dependency.  

**Key Takeaway:**  

- Even with `always @(*)`, **blocking statements execute sequentially**.  
- Using **non-blocking (`<=`)** in sequential logic prevents these issues when assignments depend on each other.

**Corrected Version (if sequential behavior is needed):**

```verilog
always @(*) begin
    y  <= qo & c;
    q0 <= a | b;
end
```

> ⚠ Using non-blocking statements ensures **all RHS signals are evaluated first**, then assigned to LHS in parallel, avoiding unexpected simulation behavior.



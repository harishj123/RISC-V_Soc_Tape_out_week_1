Got it! Here's a polished, detailed, and **GitHub-ready version** for Day 4, with a clear welcome intro, detailed explanation, and attractive formatting:

````markdown
# üöÄ Day 4: GLS, Blocking vs Non-Blocking, and Synthesis-Simulation Mismatch

Welcome to **Day 4** of our digital design journey! Today we dive into **Gate Level Simulation (GLS)**, understand **blocking vs non-blocking assignments**, and learn why **synthesis vs simulation mismatches** occur. By the end of this day, you‚Äôll understand how to validate your design **after synthesis** and ensure it works correctly with timing.

---

## üîπ What is GLS?

**GLS** stands for **Gate Level Simulation**.  

- In **RTL simulation**, the **testbench runs with the RTL code** as the Design Under Test (DUT).  
- In **GLS**, the **testbench runs with the synthesized netlist** as the DUT.  
- The **netlist** is logically the same as the RTL but expressed using **standard cell gates and flip-flops** from the target technology library.  

### Example Workflow:

```text
RTL simulation:      Testbench + RTL code
GLS simulation:      Testbench + Synthesized netlist
````

---

## ‚ùì Why GLS is Needed?

1. **Verify logical correctness after synthesis**

   * Synthesis tools convert RTL into gate-level netlists.
   * GLS ensures that the **functional behavior of the netlist matches the RTL**.

2. **Timing-aware verification**

   * RTL simulation **ignores gate delays**.
   * Netlist simulation includes **timing information** if delay annotations are present.
   * GLS checks whether the design can **meet target clock frequencies**.

3. **Delay-annotated GLS**

   * For **realistic timing validation**, GLS should be run with **annotated delays** from the standard cell library.
   * Helps catch setup/hold violations and other timing issues **before tapeout**.

4. **Detect synthesis-related mismatches**

   * Sometimes, coding style issues in RTL (e.g., improper blocking/non-blocking usage, incomplete sensitivity lists) may cause the **netlist to behave differently** from RTL.
   * GLS identifies these issues early.

5. **Final verification confidence**

   * GLS acts as a **last step of functional and timing validation** before fabrication.

---

````markdown
# üìå GLS Using Icarus Verilog (iverilog)

In previous days, we ran simulations with **RTL as the Design Under Test (DUT)**.  
In **Gate Level Simulation (GLS)**, the **DUT is the synthesized netlist** (gate-level design) instead of RTL.  

We can run GLS using **Icarus Verilog** and visualize waveforms in **GTKWave**.

---

## üîπ How GLS Works with Icarus Verilog

1. **Files Needed:**
   - **Design** ‚Üí The netlist (gate-level Verilog generated by synthesis).  
   - **Testbench** ‚Üí Stimulus file that applies inputs and checks outputs.  
   - **Gate-Level Models** ‚Üí Standard cells or library models (may include timing).  

2. **Run GLS:**
```bash
iverilog design.v testbench.v gate_lib.v -o sim.out
vvp sim.out
gtkwave dump.vcd
````

* Here, `design.v` is the **netlist** (not RTL).
* `dump.vcd` is the **waveform output** for visualization.

---

## üîπ Why GLS is Needed

* The **netlist represents the same logic as RTL**, but it is **mapped to actual gates**.
* **Timing-aware netlists** include **propagation delays** from the library.
* GLS helps in:

  1. **Timing validation** ‚Üí Ensure setup/hold times are met.
  2. **Functional verification** ‚Üí Check logical correctness after synthesis.

---

## üîπ Types of Gate-Level Models

1. **Functional Models:**

   * Only describe the **logical function** of gates.
   * No timing information.
   * Example:

```verilog
assign y = a & b; // purely logical
```

2. **Timing-Aware Models:**

   * Include **gate delays** along with logical function.
   * Example:

```verilog
and #(2) U1 (y, a, b); // 2ns delay
```

* GLS with **timing-aware models** is critical for **timing validation**, not just functional correctness.

---

## üîπ Example

Assume the netlist contains:

```verilog
assign y = (a & b) | c;
```

* The **function** of this netlist is exactly `y = (a & b) | c`.
* In GLS, we **verify that the gate-level implementation produces the same output** for all input combinations as RTL.
* If the netlist is **timing-annotated**, GLS will also show the **propagation delay effects**.

---


